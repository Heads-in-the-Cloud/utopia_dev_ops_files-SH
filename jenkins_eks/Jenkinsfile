pipeline {
  agent any

  stages{
    stage('Setup parameters') {
      steps {
        script {
          properties([
            parameters([
                [$class: 'ChoiceParameter', 
                  choiceType: 'PT_SINGLE_SELECT', 
                  description: 'Starting or stopping the cluster?', 
                  filterLength: 1, 
                  filterable: false, 
                  name: 'action', 
                  script: [
                    $class: 'GroovyScript', 
                    fallbackScript: [
                        classpath: [], 
                        sandbox: false, 
                        script: 
                            "return['Could not load actions']"
                    ], 
                    script: [
                        classpath: [], 
                        sandbox: false, 
                        script: 
                            "return['start','stop']"
                    ]
                  ]
                ],
              [$class: 'CascadeChoiceParameter', 
                choiceType: 'PT_SINGLE_SELECT', 
                description: 'Development or Production environment?',
                name: 'environment', 
                referencedParameters: 'action', 
                script: [
                  $class: 'GroovyScript', 
                  fallbackScript: [
                    classpath: [], 
                    sandbox: false, 
                    script: "return['Couldn't get operational environment from parameters']"
                  ], 
                  script: [
                    classpath: [], 
                    sandbox: false, 
                    script: '''
                    if(action.equals("start")){
                        return["dev","prod"]
                    }
                    '''
                  ] 
                ]
              ]
            ])
          ])
        }
      }
    }

    stage('retrieve secrets'){
      steps{
        script{ 
          env.ENVIRONMENT = params.environment
          env.RDS_INST = sh ( script: 'aws secretsmanager get-secret-value --secret-id prod/SeanH/utopia_secrets --region us-west-2  | jq --raw-output .SecretString | jq -r ."RDS_INST"', returnStdout: true).trim()
          env.SECRET_KEY = sh ( script: 'aws secretsmanager get-secret-value --secret-id prod/SeanH/utopia_secrets --region us-west-2  | jq --raw-output .SecretString | jq -r ."SECRET_KEY"', returnStdout: true).trim()
          env.DB_USERNAME = sh ( script: 'aws secretsmanager get-secret-value --secret-id prod/SeanH/utopia_secrets --region us-west-2  | jq --raw-output .SecretString | jq -r ."DB_USERNAME"', returnStdout: true).trim()
          env.DB_PASSWORD = sh ( script: 'aws secretsmanager get-secret-value --secret-id prod/SeanH/utopia_secrets --region us-west-2  | jq --raw-output .SecretString | jq -r ."DB_PASSWORD"', returnStdout: true).trim()
          env.AWS_REGION = "${region}"
          env.HOSTED_ZONE = "${HOSTED_ZONE}"
          env.CLUSTER_NAME = "${CLUSTER_NAME_SH}"
          env.RECORD_NAME = "utopia-sh-eks-${params.environment}.hitwc.link"
          env.AWS_ACCOUNT_ID= "${ORG_ACCOUNT_NUM}"
          env.DNS=""
          sh "echo $ENVIRONMENT"
        }
      }
    }
    
    stage('export VPC and subnet IDs'){
      when {
        expression {
          return params.action == 'start'
        }
      }
      steps{
        script{
          withCredentials(
            [[ 
              $class: 'UsernamePasswordMultiBinding', 
              credentialsId: 'aws-key-SH', 
              usernameVariable: 'AWS_ACCESS_KEY_ID', 
              passwordVariable: 'AWS_SECRET_ACCESS_KEY'
            ]]
          ) {
            VPC_ID = sh( script: "aws ec2 describe-vpcs --filter Name=tag:Name,Values=Jenkins-VPC | jq '.[] | .[].VpcId'", returnStdout: true).trim().replaceAll("\"", "")
            
            // private_subnet1 = sh( script: "aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} Name=tag:kubernetes.io/role/internal-elb,Values=1 Name=tag:kubernetes.io/cluster/${CLUSTER_NAME},Values=shared --query Subnets[].SubnetId | jq '.[0]'", returnStdout: true).trim()
            private_subnet1 = "subnet-063080fbe5367bfdc"

            //private_subnet2 = sh( script: "aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} Name=tag:kubernetes.io/role/internal-elb,Values=1 Name=tag:kubernetes.io/cluster/${CLUSTER_NAME},Values=shared --query Subnets[].SubnetId | jq '.[1]'", returnStdout: true).trim()
            private_subnet2 = "subnet-0ad40859682a6cfc8"
            sh "echo $private_subnet1"
            sh "echo $private_subnet2"
          }
        }
      }
    }

    stage('create cluster'){
      when {
        expression {
          return params.action =='start'
        }
      }
      steps{
        script{

          sh "eksctl create cluster --name=${CLUSTER_NAME_SH} --region=${AWS_REGION} --fargate \
          --vpc-private-subnets=${private_subnet1},${private_subnet2}"  
                  
        }
      }
    }

    stage('associate IAM OpenID Connect Provider'){
      when {
        expression {
          return params.action =='start'
        }
      }
      steps{
        script{

          sh "eksctl utils associate-iam-oidc-provider --cluster=$CLUSTER_NAME_SH --approve"
                                
        }
      }
    }

    stage('set up ingress controller'){
      when {
        expression {
          return params.action =='start'
        }
      }
      steps{
        script{

          sh "kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/aws-alb-ingress-controller/v1.1.4/docs/examples/rbac-role.yaml"

          sh "eksctl create iamserviceaccount \
              --name=alb-ingress-controller \
              --namespace=kube-system \
              --cluster=${CLUSTER_NAME_SH} \
              --attach-policy-arn=arn:aws:iam::${ORG_ACCOUNT_NUM}:policy/ALBIngressControllerIAMPolicy \
              --override-existing-serviceaccounts \
              --approve"

          sh "curl -sS 'https://raw.githubusercontent.com/kubernetes-sigs/aws-alb-ingress-controller/v1.1.4/docs/examples/alb-ingress-controller.yaml' \
              | sed 's/# - --cluster-name=devCluster/- --cluster-name=${CLUSTER_NAME_SH}/g' \
              | sed 's/# - --aws-vpc-id=vpc-xxxxxx/- --aws-vpc-id=${VPC_ID}/g' \
              | sed 's/# - --aws-region=us-west-1/- --aws-region=${region}/g' \
              | kubectl apply -f -"  
                                          
        }
      }
    }

    stage('apply kubectl yamls'){
      when {
        expression {
          return params.action =='start'
        }
      }
      steps{
        script{
          dir("kubernetes/eks") {

            sh "chmod +x start.sh"
            sh "./start.sh"
                                  
          }
        }
      }
    }

    stage('set up Route53'){
      when {
        expression {
          return params.action =='start'
        }
      }
      steps{
        script{
          dir("kubernetes/eks") {
            sh "sleep 200"
            DNS = sh (script: "timeout 200s bash -c 'until kubectl get ingress utopia-ingress --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}'; do : ; done'", returnStdout: true).trim()

            sh """aws route53 change-resource-record-sets --hosted-zone-id $HOSTED_ZONE --change-batch '
            {
              "Comment": "Testing creating a record set",
              "Changes": [{
                  "Action"              : "CREATE",
                  "ResourceRecordSet"  : {
                    "Name"              : "'$RECORD_NAME'",
                    "Type"             : "CNAME",
                    "TTL"              : 120,
                    "ResourceRecords"  : [{
                        "Value"         : "'$DNS'"
                    }]
                  }
              }]
            }
            '"""
          }
        }
      }
    }

    stage('delete cluster'){
      when {
        expression { 
          return params.action == 'stop'
        }
      }
      steps {
        dir("kubernetes/eks") {
          sh 'chmod +x stop.sh'
          sh './stop.sh'              
        }
      }
    }

  }
}
